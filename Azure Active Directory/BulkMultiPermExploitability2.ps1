<#
.SYNOPSIS
  Reads ScopeBreakdown.csv, checks each AppId for potential exploitability via multiple high-risk Microsoft Graph permissions.
  Flags both privilege escalation and data-access risks, with clear reasons.

.PARAMETER ScopeCsvPath
  Path to ScopeBreakdown.csv.

.PARAMETER ResourceAppId
  Resource AppId to check against; default is Microsoft Graph.

.PARAMETER HighRiskPermissions
  List of permissions to evaluate.

.PARAMETER OutputPath
  Folder to save CSV summary.
#>

param(
  [Parameter(Mandatory=$true)]
  [string]$ScopeCsvPath,

  [string]$ResourceAppId = "00000003-0000-0000-c000-000000000000",

  [string[]]$HighRiskPermissions = @(
      # Privilege escalation
      "Group.ReadWrite.All",
      "Directory.ReadWrite.All",
      "Application.ReadWrite.All",
      "PrivilegedAccess.ReadWrite.AzureAD",
      "PrivilegedAccess.ReadWrite.AzureADGroup",
      "PrivilegedAccess.ReadWrite.AzureResources",
      "User.ReadWrite.All",
      "DeviceManagementManagedDevices.PrivilegedOperations.All",

      # Data access / exfiltration
      "Mail.ReadWrite",
      "Mail.ReadWrite.All",
      "Files.ReadWrite",
      "Files.ReadWrite.All",
      "Sites.ReadWrite.All",
      "Calendars.ReadWrite",
      "Calendars.ReadWrite.All",
      "Contacts.ReadWrite",
      "Contacts.ReadWrite.All"
  ),

  [string]$OutputPath = "$PSScriptRoot"
)

Write-Host "=== Bulk multi-permission exploitability check starting ===" -ForegroundColor Yellow

# Ensure modules
if (-not (Get-Module -ListAvailable -Name Microsoft.Graph)) {
  Install-Module Microsoft.Graph -Scope CurrentUser -Force
}
if (-not (Get-Module -ListAvailable -Name MSAL.PS)) {
  Install-Module MSAL.PS -Scope CurrentUser -Force
}
Import-Module Microsoft.Graph
Import-Module MSAL.PS

function Test-GraphConnection {
    $ctx = Get-MgContext
    return ($ctx -and $ctx.Account)
}

# Connect once using built-in app ID, fallback if needed
Write-Host "Connecting to Microsoft Graph..." -ForegroundColor Cyan
try {
    $TokenResponse = Get-MsalToken -ClientId "1b730954-1685-4b74-9bfd-dac224a7b894" -TenantId "common" -Interactive
    $secureToken = ConvertTo-SecureString $TokenResponse.AccessToken -AsPlainText -Force
    Connect-MgGraph -AccessToken $secureToken
} catch {
    Write-Warning "Built-in app connection failed: $($_.Exception.Message)"
}
if (-not (Test-GraphConnection)) {
    Write-Host "Falling back to Graph SDK client..." -ForegroundColor Cyan
    Connect-MgGraph -Scopes "Application.Read.All","AppRoleAssignment.Read.All","Directory.Read.All","DelegatedPermissionGrant.Read.All" -NoWelcome
    if (-not (Test-GraphConnection)) {
        throw "No successful Graph connection established."
    }
}

Write-Host "Connected to Microsoft Graph." -ForegroundColor Green

# Resolve Microsoft Graph SP
$graphSp = Get-MgServicePrincipal -Filter "appId eq '$ResourceAppId'"
if (-not $graphSp) { throw "Microsoft Graph SP not found in tenant." }

# Build permission maps
$delegatedMap = @{}
foreach ($s in $graphSp.Oauth2PermissionScopes) {
  $delegatedMap[$s.Value] = [PSCustomObject]@{ Id = $s.Id; Type = "Delegated"; Name = $s.Value; Description = $s.AdminConsentDisplayName }
}
$appRoleMap = @{}
foreach ($r in $graphSp.AppRoles) {
  $appRoleMap[$r.Value] = [PSCustomObject]@{ Id = $r.Id; Type = "Application"; Name = $r.Value; Description = $r.DisplayName }
}

# Read CSV and get unique AppIds
$scopeData = Import-Csv $ScopeCsvPath
$appIds = $scopeData.AppId | Sort-Object -Unique

Write-Host ("Found {0} unique AppIds in CSV." -f $appIds.Count) -ForegroundColor Cyan

$results = @()

foreach ($appId in $appIds) {
    try {
        $app = Get-MgApplication -Filter "appId eq '$appId'"
        $sp  = Get-MgServicePrincipal -Filter "appId eq '$appId'"

        if (-not $app -or -not $sp) {
            Write-Host "$appId → Not found in tenant" -ForegroundColor DarkYellow
            continue
        }

        $hasPasswordCreds = ($app.PasswordCredentials | Measure-Object).Count -gt 0
        $hasKeyCreds      = ($app.KeyCredentials | Measure-Object).Count -gt 0

        $delegatedHitCount = 0
        $applicationHitCount = 0
        $tenantWideDelegatedCount = 0
        $problemReasons = @()

        foreach ($permName in $HighRiskPermissions) {
            $targetDelegated = $delegatedMap[$permName]
            $targetAppRole   = $appRoleMap[$permName]

            # Delegated grants
            $delegatedGrants = Get-MgOauth2PermissionGrant -Filter "clientId eq '$($sp.Id)' and resourceId eq '$($graphSp.Id)'" -All
            foreach ($g in $delegatedGrants) {
                if ($g.Scope -and ($g.Scope.Split(' ') -contains $permName)) {
                    $delegatedHitCount++
                    if ($g.ConsentType -eq "AllPrincipals") {
                        $tenantWideDelegatedCount++
                        $problemReasons += "Tenant-wide delegated: $permName"
                    }
                }
            }

            # Application assignments
            $appRoleAssignments = Get-MgServicePrincipalAppRoleAssignedTo -ServicePrincipalId $sp.Id -All | Where-Object { $_.ResourceId -eq $graphSp.Id }
            foreach ($a in $appRoleAssignments) {
                if ($targetAppRole -and $a.AppRoleId -eq $targetAppRole.Id) {
                    $applicationHitCount++
                    if ($hasPasswordCreds -or $hasKeyCreds) {
                        $problemReasons += "App-only + credential: $permName"
                    }
                }
            }
        }

        $exploitable = $problemReasons.Count -gt 0
        if ($exploitable) {
            Write-Host "$appId → Problem! ($($problemReasons -join '; '))" -ForegroundColor Red
        } else {
            Write-Host "$appId → looks ok" -ForegroundColor Green
        }

        $results += [PSCustomObject]@{
            AppId                     = $appId
            DelegatedHitCount         = $delegatedHitCount
            ApplicationHitCount       = $applicationHitCount
            TenantWideDelegatedCount  = $tenantWideDelegatedCount
            HasPasswordCredentials    = $hasPasswordCreds
            HasKeyCredentials         = $hasKeyCreds
            ExploitableHighRisk       = $exploitable
            ProblemReason             = ($problemReasons -join '; ')
        }

    } catch {
        Write-Host "$appId → Error: $($_.Exception.Message)" -ForegroundColor DarkRed
    }
}

# Export results
$results | Export-Csv (Join-Path $OutputPath "BulkMultiPermExploitabilityReport.csv") -NoTypeInformation
Write-Host "=== Bulk multi-permission exploitability check complete ===" -ForegroundColor Yellow
Write-Host ("Report saved to {0}" -f (Join-Path $OutputPath "BulkMultiPermExploitabilityReport.csv")) -ForegroundColor Cyan

Disconnect-MgGraph